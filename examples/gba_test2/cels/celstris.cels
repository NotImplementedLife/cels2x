import "celstris_bindings.cels";

extern function scanKeys():void;
extern function keysDown():ushort;
extern function dir_x(keys:int):int;
extern function dir_y(keys:int):int;

package Celstris
begin
	struct State
	begin
		var shadow_map: short[1024];
		
		function set_color(row:int, col:int, color:short):void
		begin
			shadow_map[32*row+col]=color;
		end;
	end;
	
	function clip(x:int, a:int, b:int):int 
	begin
		if x<a then return a; fi;
		if x>b then return b; fi;
		return x;
	end;
	
	multiframe function npc_move(state: State*): void
	begin
	
	end;
	
	multiframe function main_loop(state: State*): void
	begin
		/* TO DO: taskstart NPC here */
		
		var task = taskstart lambda() => begin npc_move(state); end;
		
		var x = 0;
		var y = 0;
		var c = 1;
		while 1 do begin
			scanKeys();
			var kdown = keysDown();
			var dx = dir_x(kdown);
			var dy = dir_y(kdown);
			
			state->set_color(y, x, 0);
			
			x = clip(x + dx, 0, 29);
			y = clip(y + dy, 0, 19);
			
			state->set_color(y, x, c);
			c = (c+1)%8;
			suspend;
		end;
	end;
end;

/*package Celstris
begin
	multiframe function process_user_input(gs: GameState*, piece:Piece*):void
	begin
		var i=0;	
		while i<10 do
		begin
			var dx = 0;
			if left_key_down()!=0 then dx = 0-1; end;
			if right_key_down()!=0 then dx = 1; end;
			
			if dx!=0 then
				GameState_piece_move_if_possible(gs, piece, dx, 0);
			end;
			
			if down_key_held()!=0 then 
				GameState_piece_move_if_possible(gs, piece, 0, 1);
			end;
			
			i=i+1;
			suspend;
		end;
	end;
	
	multiframe function main_loop(gs: GameState*): void 
	begin
		var running = 1;
		while running>0 do
		begin
			var piece = GameState_generate_random_piece(gs);
			if GameState_test_piece(gs, piece)>0
			then begin
				var falling_down = 1;
				while falling_down>0 do begin
					process_user_input(gs, piece);
					if GameState_piece_move_if_possible(gs, piece, 0, 1)==0 then 
						falling_down = 0;
					end;				
				end;
				GameState_place_piece(gs, piece);
			end;
			else begin
				GameState_reset(gs);
			end; end;
			

		end;
	end;		

end;*/